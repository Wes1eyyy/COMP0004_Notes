#### æŠ½è±¡ç±»(Abstract class): 
æŠ½è±¡ç±»æ˜¯ä¸€ä¸ªè¶…ç±»ï¼Œå®ƒæä¾›æ–¹æ³•å®šä¹‰è€Œæ²¡æœ‰ç‰¹å®šçš„å®ç°ï¼Œå…è®¸å­ç±»ç»§æ‰¿å’Œå®ç°æŠ½è±¡æ–¹æ³•ä»¥å®ç°ä»£ç é‡ç”¨
- "An abstract class is a superclass that provides method definitions without specific implementations, allowing subclasses to inherit and implement the abstract methods to achieve code reuse."

#### æ¥å£(Interface): 
åœ¨ Java ä¸­ï¼Œinterfaceï¼ˆæ¥å£ï¼‰æ˜¯ä¸€ä¸ªåªèƒ½åŒ…å«æ–¹æ³•å®šä¹‰çš„è“å›¾ï¼Œè¦æ±‚å®ç°çš„ç±»æä¾›å…·ä½“çš„å®ç°ã€‚å®ƒå¯ä»¥ä½¿å¤šä¸ªç±»å…±äº«é€šç”¨åè®®ï¼Œå¹¶é€šè¿‡æ”¯æŒå¤šé‡ç»§æ‰¿å’Œè§£è€¦åˆï¼Œæå‡çµæ´»æ€§å’ŒæŠ½è±¡æ€§ã€‚
- "In Java, an `interface` is a blueprint that can only contain method definitions, requiring implementing classes to provide the actual implementation. It allows multiple classes to share a common protocol, and by supporting multiple inheritance and decoupling, it enhances flexibility and abstraction."

#### CæŒ‡é’ˆå’ŒJavaæŒ‡é’ˆ: 
C æŒ‡é’ˆå…è®¸ç›´æ¥æ“ä½œå†…å­˜åœ°å€ï¼Œé€šè¿‡æŒ‡é’ˆç®—æœ¯å¯ä»¥çµæ´»åœ°éå†æˆ–ä¿®æ”¹æ•°æ®ï¼Œä½†éœ€è¦æ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œå®¹æ˜“å¼•å‘é”™è¯¯ã€‚è€Œ Java å¼•ç”¨æ˜¯å¯¹å¯¹è±¡çš„æŠ½è±¡å¥æŸ„ï¼Œç”±åƒåœ¾å›æ”¶æœºåˆ¶è‡ªåŠ¨ç®¡ç†ï¼Œä¸å…è®¸ç›´æ¥è®¿é—®å†…å­˜åœ°å€ï¼Œä»è€Œå¢å¼ºäº†å®‰å…¨æ€§å’Œç¨³å®šæ€§ï¼Œä½†ä¹Ÿå› æ­¤ç¼ºä¹æŒ‡é’ˆçš„çµæ´»æ€§ã€‚
é¢˜ç›®è¦æ±‚æ¯”è¾ƒ C è¯­è¨€çš„æŒ‡é’ˆä¸ Java ä¸­çš„å¼•ç”¨ã€‚ä»¥ä¸‹æ˜¯äºŒè€…ä¹‹é—´çš„ä¸»è¦åŒºåˆ«ï¼š

1. **ç±»å‹**ï¼š
   - **C æŒ‡é’ˆ**ï¼šæ˜¯å†…å­˜åœ°å€çš„å˜é‡ï¼Œç±»å‹å¯ä»¥æ˜¯ä»»æ„æ•°æ®ç±»å‹çš„æŒ‡é’ˆï¼Œå¦‚ `int*`, `char*`, `void*`ï¼Œç”šè‡³æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆã€‚
   - **Java å¼•ç”¨**ï¼šåœ¨ Java ä¸­ï¼Œå¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡å‘å¯¹è±¡çš„å¥æŸ„ï¼Œç”¨äºè®¿é—®å¯¹è±¡ï¼Œå¼•ç”¨ç±»å‹æ˜¯å¯¹è±¡çš„ç±»æˆ–æ¥å£ã€‚

2. **ç›´æ¥æ“ä½œå†…å­˜**ï¼š
   - **C æŒ‡é’ˆ**ï¼šå…è®¸ç›´æ¥è®¿é—®å’Œä¿®æ”¹å†…å­˜åœ°å€çš„å€¼ï¼Œè¿™æ„å‘³ç€å¯ä»¥é€šè¿‡æŒ‡é’ˆç®—æœ¯æ“ä½œæ¥éå†æ•°ç»„ã€è®¿é—®å†…å­˜æˆ–ä¿®æ”¹å˜é‡å€¼ã€‚
   - **Java å¼•ç”¨**ï¼šä¸å…è®¸ç›´æ¥æ“ä½œå†…å­˜æˆ–è¿›è¡ŒæŒ‡é’ˆç®—æœ¯ã€‚Java å¼•ç”¨ç”± Java è™šæ‹Ÿæœºç®¡ç†ï¼Œç¨‹åºå‘˜æ— æ³•çœ‹åˆ°å†…å­˜åœ°å€æˆ–ç›´æ¥ä¿®æ”¹å®ƒã€‚

3. **ç©ºæŒ‡é’ˆ**ï¼š
   - **C æŒ‡é’ˆ**ï¼šå¦‚æœä¸€ä¸ªæŒ‡é’ˆæœªè¢«åˆå§‹åŒ–æˆ–è€…è¢«è®¾ç½®ä¸º `NULL`ï¼Œè®¿é—®å®ƒä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚
   - **Java å¼•ç”¨**ï¼šå¦‚æœå¼•ç”¨ä¸º `null`ï¼Œè¯•å›¾è°ƒç”¨å…¶æ–¹æ³•æˆ–è®¿é—®å…¶å±æ€§ä¼šæŠ›å‡º `NullPointerException`ï¼Œè¿™æ˜¯ä¸€ç§å—æ§çš„å¼‚å¸¸ã€‚

4. **åƒåœ¾å›æ”¶**ï¼š
   - **C æŒ‡é’ˆ**ï¼šéœ€è¦ç¨‹åºå‘˜æ‰‹åŠ¨ç®¡ç†æŒ‡é’ˆçš„åˆ†é…å’Œé‡Šæ”¾ï¼Œé”™è¯¯çš„å†…å­˜ç®¡ç†å¯èƒ½ä¼šå¯¼è‡´å†…å­˜æ³„æ¼æˆ–æ‚¬ç©ºæŒ‡é’ˆã€‚
   - **Java å¼•ç”¨**ï¼šç”± Java çš„åƒåœ¾æ”¶é›†å™¨è‡ªåŠ¨å¤„ç†å¯¹è±¡çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå¼•ç”¨ä¸å†ä½¿ç”¨çš„å¯¹è±¡ä¼šè¢«è‡ªåŠ¨å›æ”¶ï¼Œå‡å°‘äº†å†…å­˜æ³„æ¼çš„é£é™©ã€‚
- "C pointers allow direct manipulation of memory addresses. Pointer arithmetic enables flexible data traversal and modification, but requires manual memory management, leading to potential errors. In contrast, Java references are abstract handles to objects, automatically managed by garbage collection. They don't allow direct memory access, thus enhancing safety and stability but lacking the flexibility of pointers."
1. **æ‰¾åˆ°åœ¨ ğ´ğ·ğ»ğ¸ å¹³é¢çš„æŠ•å½±ï¼š** 


**Explain how a Java String is represented, and what happens when the expression a == b is evaluated if a and b are two variables of type String.**
åœ¨Javaä¸­ï¼Œ`String` è¢«è¡¨ç¤ºä¸ºå°è£…å­—ç¬¦åºåˆ—çš„å¯¹è±¡ã€‚å­—ç¬¦ä¸²æ˜¯ `java.lang.String` ç±»çš„å®ä¾‹ï¼Œå¹¶å­˜å‚¨åœ¨ä¸€ä¸ªç‰¹æ®Šçš„å†…å­˜åŒºåŸŸï¼Œç§°ä¸ºå­—ç¬¦ä¸²æ± ã€‚è¿™ä¸ªæ± é€šè¿‡é‡ç”¨åŒ…å«ç›¸åŒå­—ç¬¦åºåˆ—çš„å­—ç¬¦ä¸²å®ä¾‹æ¥èŠ‚çœå†…å­˜ã€‚

å½“è¡¨è¾¾å¼ `a == b` è¢«æ±‚å€¼ï¼Œä¸” `a` å’Œ `b` æ˜¯ç±»å‹ä¸º `String` çš„å˜é‡æ—¶ï¼Œ`==` è¿ç®—ç¬¦æ£€æŸ¥çš„æ˜¯å¼•ç”¨ç­‰åŒæ€§(reference equality)ï¼Œè€Œä¸æ˜¯å†…å®¹ç­‰åŒæ€§ã€‚è¿™æ„å‘³ç€å¦‚æœ `a` å’Œ `b` æŒ‡å‘å†…å­˜ä¸­åŒä¸€ä¸ª `String` å¯¹è±¡ï¼ˆå³å®ƒä»¬æ˜¯åŒä¸€ä¸ªå®ä¾‹ï¼‰ï¼Œåˆ™ `a == b` è¿”å› `true`ã€‚å¦‚æœ `a` å’Œ `b` æŒ‡å‘ä¸åŒçš„å¯¹è±¡ï¼Œå³ä½¿è¿™äº›å¯¹è±¡åŒ…å«ç›¸åŒçš„å­—ç¬¦åºåˆ—ï¼Œ`a == b` ä¹Ÿè¿”å› `false`ã€‚è¦æ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å…·æœ‰ç›¸åŒçš„å†…å®¹ï¼Œåº”ä½¿ç”¨ `.equals()` æ–¹æ³•ï¼Œå› ä¸ºå®ƒæ¯”è¾ƒå­—ç¬¦ä¸²å†…çš„å­—ç¬¦ã€‚

#### é”™è¯¯å¤„ç†(Error Handling)
**try**: ç”¨äºå®šä¹‰ä¸€ä¸ªä»£ç å—ï¼Œåœ¨å…¶ä¸­æ‰§è¡Œå¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸çš„ä»£ç ã€‚
- Used to define a block of code in which code that might throw an exception is executed.

**catch**: ç”¨äºæ•è·å’Œå¤„ç† `try` å—ä¸­æŠ›å‡ºçš„å¼‚å¸¸ã€‚
- Used to catch and handle exceptions thrown within the try block.

**throw**: ç”¨äºæ‰‹åŠ¨æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸å®ä¾‹ã€‚
- Used to manually throw an instance of an exception.

**throws**: åœ¨æ–¹æ³•ç­¾åä¸­ä½¿ç”¨ï¼Œå£°æ˜è¯¥æ–¹æ³•å¯èƒ½ä¼šæŠ›å‡ºçš„å¼‚å¸¸ç±»å‹ã€‚
- Used in method signatures to declare the types of exceptions that the method might throw

**finally**: å®šä¹‰ä¸€ä¸ªä»£ç å—ï¼Œæ— è®ºæ˜¯å¦å‘ç”Ÿå¼‚å¸¸ï¼Œè¯¥å—ä¸­çš„ä»£ç éƒ½å°†è¢«æ‰§è¡Œã€‚
- Defines a block of code that is executed regardless of whether an exception is thrown or not.

### **åŸå§‹ç±»å‹**å’Œ**ç±»ç±»å‹**ã€‚

#### åŸå§‹ç±»å‹
- ç›´æ¥å­˜å‚¨å€¼ï¼Œä¸æ˜¯å¯¹è±¡ã€‚
- å­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­ï¼Œè®¿é—®é€Ÿåº¦å¿«ã€‚
- ä¸èƒ½æ˜¯`null`ã€‚
- ç¤ºä¾‹ï¼š`int`, `double`, `boolean`, `char`ã€‚

#### ç±»ç±»å‹
- å­˜å‚¨æ•°æ®çš„å¼•ç”¨ï¼Œè€Œéæ•°æ®æœ¬èº«ã€‚
- å¯ä»¥æ˜¯`null`ã€‚
- å­˜å‚¨åœ¨å †å†…å­˜ä¸­ï¼Œè®¿é—®ç›¸å¯¹æ…¢ã€‚
- ç¤ºä¾‹ï¼š`String`, `Integer`ï¼ˆåŒ…è£…ç±»ï¼‰ï¼Œæ•°ç»„ï¼Œç”¨æˆ·å®šä¹‰çš„ç±»å¦‚`Car`ã€‚

**å¯¹æ¯”**ï¼š
- åŸå§‹ç±»å‹æ›´å¿«ã€å ç”¨å†…å­˜æ›´å°‘ï¼›ç±»ç±»å‹åœ¨å †ä¸­ï¼Œæ”¯æŒé¢å‘å¯¹è±¡ç‰¹æ€§å¦‚æ–¹æ³•å’Œç»§æ‰¿ã€‚
- åŸå§‹ç±»å‹ç”¨äºå­˜å‚¨ç®€å•æ•°æ®ï¼Œç±»ç±»å‹ç”¨äºå®ç°é¢å‘å¯¹è±¡ç¼–ç¨‹ã€‚



**å¼±ç±»å‹**ï¼šå˜é‡å¯ä»¥åœ¨æ²¡æœ‰æ˜¾å¼è½¬æ¢çš„æƒ…å†µä¸‹è¢«éšå¼åœ°å¼ºåˆ¶è½¬æ¢ä¸ºä¸åŒç±»å‹ã€‚

**å¼ºç±»å‹**ï¼šç±»å‹è¢«ä¸¥æ ¼æ‰§è¡Œï¼Œå˜é‡é€šå¸¸ä¸èƒ½éšå¼è½¬æ¢ã€‚

**é™æ€ç±»å‹**ï¼šå˜é‡ç±»å‹åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¹¶è¿›è¡Œæ£€æŸ¥ï¼Œç¡®ä¿åœ¨è¿è¡Œå‰æ•è·ç±»å‹é”™è¯¯ã€‚

**åŠ¨æ€ç±»å‹**ï¼šå˜é‡ç±»å‹åœ¨è¿è¡Œæ—¶ç¡®å®šï¼Œæä¾›æ›´å¤šçµæ´»æ€§ï¼Œä½†ä¹Ÿå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶ç±»å‹é”™è¯¯ã€‚

**Weak typing**: Variables can be implicitly coerced to different types without explicit conversion.

**Strong typing**: Types are strictly enforced, and variables typically cannot be converted implicitly.

**Static typing**: Variable types are known and checked at compile-time, ensuring type errors are caught before runtime.

**Dynamic typing**: Variable types are determined at runtime, allowing more flexibility but at the risk of runtime type errors.